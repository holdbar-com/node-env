#!/usr/bin/env node
import { readFile, writeFile } from 'node:fs/promises';
import { join, resolve } from 'node:path';
import { getHash, getTag, getTags, isClean } from '../lib/git.js';
const p = resolve(process.cwd(), process.argv[2] ?? '.');
const packageJson = JSON.parse(await readFile(join(p, 'package.json'), 'utf-8'));
async function assertClean() {
    if (packageJson.gitHead) {
        const { gitHead, ...headless } = packageJson;
        await writeFile(join(p, 'package.json'), JSON.stringify(headless, undefined, '  ') + '\n', 'utf-8');
    }
    if (!(await isClean(p))) {
        throw new Error('Build does not have a git hash.');
    }
}
async function assertUntagged() {
    const [t, ts] = await Promise.all([getTag(p), getTags(p)]);
    const { version } = packageJson;
    if (t === `v${version}`) {
        return; // Since we're clean
    }
    if (ts.includes(`v${version}`)) {
        throw Error('Version already built. Please update package.json.');
    }
}
try {
    await Promise.all([assertClean(), assertUntagged()]);
    const gitHead = await getHash(p);
    await writeFile(join(p, 'package.json'), JSON.stringify({
        ...packageJson,
        gitHead,
    }, undefined, '  '), 'utf-8');
}
catch (e) {
    console.error(e.message);
    process.exit(1);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJlcHVibGlzaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInByZXB1Ymxpc2gudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUVBLE9BQU8sRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDdkQsT0FBTyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDMUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUVsRSxNQUFNLENBQUMsR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7QUFDekQsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FDNUIsTUFBTSxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxjQUFjLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FJakQsQ0FBQztBQUVGLEtBQUssVUFBVSxXQUFXO0lBQ3hCLElBQUksV0FBVyxDQUFDLE9BQU8sRUFBRTtRQUN2QixNQUFNLEVBQUUsT0FBTyxFQUFFLEdBQUcsUUFBUSxFQUFFLEdBQUcsV0FBVyxDQUFDO1FBQzdDLE1BQU0sU0FBUyxDQUNiLElBQUksQ0FBQyxDQUFDLEVBQUUsY0FBYyxDQUFDLEVBQ3ZCLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsR0FBRyxJQUFJLEVBQ2hELE9BQU8sQ0FDUixDQUFDO0tBQ0g7SUFDRCxJQUFJLENBQUMsQ0FBQyxNQUFNLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQztLQUNwRDtBQUNILENBQUM7QUFFRCxLQUFLLFVBQVUsY0FBYztJQUMzQixNQUFNLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNELE1BQU0sRUFBRSxPQUFPLEVBQUUsR0FBRyxXQUFXLENBQUM7SUFFaEMsSUFBSSxDQUFDLEtBQUssSUFBSSxPQUFPLEVBQUUsRUFBRTtRQUN2QixPQUFPLENBQUMsb0JBQW9CO0tBQzdCO0lBQ0QsSUFBSSxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksT0FBTyxFQUFFLENBQUMsRUFBRTtRQUM5QixNQUFNLEtBQUssQ0FBQyxvREFBb0QsQ0FBQyxDQUFDO0tBQ25FO0FBQ0gsQ0FBQztBQUVELElBQUk7SUFDRixNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxXQUFXLEVBQUUsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDckQsTUFBTSxPQUFPLEdBQUcsTUFBTSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDakMsTUFBTSxTQUFTLENBQ2IsSUFBSSxDQUFDLENBQUMsRUFBRSxjQUFjLENBQUMsRUFDdkIsSUFBSSxDQUFDLFNBQVMsQ0FDWjtRQUNFLEdBQUcsV0FBVztRQUNkLE9BQU87S0FDUixFQUNELFNBQVMsRUFDVCxJQUFJLENBQ0wsRUFDRCxPQUFPLENBQ1IsQ0FBQztDQUNIO0FBQUMsT0FBTyxDQUFDLEVBQUU7SUFDVixPQUFPLENBQUMsS0FBSyxDQUFFLENBQXlCLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDbEQsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUNqQiIsInNvdXJjZXNDb250ZW50IjpbIiMhL3Vzci9iaW4vZW52IG5vZGVcblxuaW1wb3J0IHsgcmVhZEZpbGUsIHdyaXRlRmlsZSB9IGZyb20gJ25vZGU6ZnMvcHJvbWlzZXMnO1xuaW1wb3J0IHsgam9pbiwgcmVzb2x2ZSB9IGZyb20gJ25vZGU6cGF0aCc7XG5pbXBvcnQgeyBnZXRIYXNoLCBnZXRUYWcsIGdldFRhZ3MsIGlzQ2xlYW4gfSBmcm9tICcuLi9saWIvZ2l0LmpzJztcblxuY29uc3QgcCA9IHJlc29sdmUocHJvY2Vzcy5jd2QoKSwgcHJvY2Vzcy5hcmd2WzJdID8/ICcuJyk7XG5jb25zdCBwYWNrYWdlSnNvbiA9IEpTT04ucGFyc2UoXG4gIGF3YWl0IHJlYWRGaWxlKGpvaW4ocCwgJ3BhY2thZ2UuanNvbicpLCAndXRmLTgnKVxuKSBhcyB7XG4gIHZlcnNpb246IHN0cmluZztcbiAgZ2l0SGVhZD86IHN0cmluZztcbn07XG5cbmFzeW5jIGZ1bmN0aW9uIGFzc2VydENsZWFuKCkge1xuICBpZiAocGFja2FnZUpzb24uZ2l0SGVhZCkge1xuICAgIGNvbnN0IHsgZ2l0SGVhZCwgLi4uaGVhZGxlc3MgfSA9IHBhY2thZ2VKc29uO1xuICAgIGF3YWl0IHdyaXRlRmlsZShcbiAgICAgIGpvaW4ocCwgJ3BhY2thZ2UuanNvbicpLFxuICAgICAgSlNPTi5zdHJpbmdpZnkoaGVhZGxlc3MsIHVuZGVmaW5lZCwgJyAgJykgKyAnXFxuJyxcbiAgICAgICd1dGYtOCdcbiAgICApO1xuICB9XG4gIGlmICghKGF3YWl0IGlzQ2xlYW4ocCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCdWlsZCBkb2VzIG5vdCBoYXZlIGEgZ2l0IGhhc2guJyk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gYXNzZXJ0VW50YWdnZWQoKSB7XG4gIGNvbnN0IFt0LCB0c10gPSBhd2FpdCBQcm9taXNlLmFsbChbZ2V0VGFnKHApLCBnZXRUYWdzKHApXSk7XG4gIGNvbnN0IHsgdmVyc2lvbiB9ID0gcGFja2FnZUpzb247XG5cbiAgaWYgKHQgPT09IGB2JHt2ZXJzaW9ufWApIHtcbiAgICByZXR1cm47IC8vIFNpbmNlIHdlJ3JlIGNsZWFuXG4gIH1cbiAgaWYgKHRzLmluY2x1ZGVzKGB2JHt2ZXJzaW9ufWApKSB7XG4gICAgdGhyb3cgRXJyb3IoJ1ZlcnNpb24gYWxyZWFkeSBidWlsdC4gUGxlYXNlIHVwZGF0ZSBwYWNrYWdlLmpzb24uJyk7XG4gIH1cbn1cblxudHJ5IHtcbiAgYXdhaXQgUHJvbWlzZS5hbGwoW2Fzc2VydENsZWFuKCksIGFzc2VydFVudGFnZ2VkKCldKTtcbiAgY29uc3QgZ2l0SGVhZCA9IGF3YWl0IGdldEhhc2gocCk7XG4gIGF3YWl0IHdyaXRlRmlsZShcbiAgICBqb2luKHAsICdwYWNrYWdlLmpzb24nKSxcbiAgICBKU09OLnN0cmluZ2lmeShcbiAgICAgIHtcbiAgICAgICAgLi4ucGFja2FnZUpzb24sXG4gICAgICAgIGdpdEhlYWQsXG4gICAgICB9LFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgJyAgJ1xuICAgICksXG4gICAgJ3V0Zi04J1xuICApO1xufSBjYXRjaCAoZSkge1xuICBjb25zb2xlLmVycm9yKChlIGFzIHsgbWVzc2FnZTogc3RyaW5nIH0pLm1lc3NhZ2UpO1xuICBwcm9jZXNzLmV4aXQoMSk7XG59XG4iXX0=